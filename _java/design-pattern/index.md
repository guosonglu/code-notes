---
layout: docs
title: 设计模式（Java语言描述）
nav_order: 4
---

# 概述

参考网站：[设计模式](https://refactoringguru.cn/design-patterns)

书籍推荐： [设计模式 : 可复用面向对象软件的基础](https://book.douban.com/subject/1052241/)

书籍推荐：[Head First 设计模式（中文版）](https://book.douban.com/subject/2243615/)

⭐设计模式是建立在`面向对象`的基础之上的，如果对面向对象相关知识不是很了解，
可以参考：[面向对象](/general/object-oriented-analysis/index.html)部分

# 设计原则

优秀设计的特性：
- 代码复用
- 拓展性

## 封装变化的内容

找到程序中变化的内容将其与不变的内容分开

`目的`：将变化造成的影响最小化

## 面向接口进行开发，而不是面向实现

依赖于抽象类型，而不是具体类

## 组合或聚合优于继承

继承存在的问题：
- 子类不能减少超类的接口
- 在重写方法时，需要确保新行为与基类中的版本兼容
- 继承打破了超类的封装
- 子类与超累紧密耦合
- 通过继承复用代码可能导致平行继承体系的产生

继承代表`是`关系：汽车`是`交通工具
组合表示`有`关系：汽车`有`一个引擎

## 单一职责原则

尽量让每个类只负责软件中的一个功能，并将该功能完全封装（你也可称之为隐藏）在该类中。

## 开闭原则

对于扩展，类应该是“开放”的；对于修改，类则应是“封闭”的。实现新功能时保持已有代码不变。

## 里氏替换原则

当你扩展一个类时，记住你应该要能在不修改客户端代码的情况下将子类的对象作为父类对象进行传递。

- 子类方法的参数类型必须与其超类的参数类型相匹配或更加抽象。
- 子类方法的返回值类型必须与超类方法的返回值类型或是其子类别相匹配。
- 子类中的方法不应抛出基础方法预期之外的异常类型。
- 子类不应该加强其前置条件。
- 子类不能削弱其后置条件。
- 超类的不变量必须保留。
- 子类不能修改超类中私有成员变量的值。

## 接口隔离原则

客户端不应被强迫依赖于其不使用的方法。

尽量缩小接口的范围，使得客户端的类不必实现其不需要的行为。


## 依赖倒置原则

高层次的类不应该依赖于低层次的类。 两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽象接口。

`依赖倒置原则`通常和`开闭原则`共同发挥作用：你无需修改已有类就能用不同的业务逻辑类扩展低层次的类。

# 创建型模式

创建型模式提供了创建对象的机制，能够提升已有代码的灵活性和可复用性

## 工厂方法

### 意图

定义一个用于`创建对象的接口（或抽象方法）`，让子类决定实例化哪一个类。使实例化某个类的操作延续到子类。

### 别名

- 虚构造器
- Virtual Constructor

### 结构

- 产品（Product）
  - 将会对接口进行声明。

### 实现方式

- 让所有产品都`遵循同一接口`。该接口必须声明对所有产品都有意义的方法。
- 在创建类中添加一个空的工厂方法。该方法的返回类型必须遵循通用的产品接口。
- 在创建者代码中找到对于产品构造函数的所有引用。将它们依次替换为对于工厂方法的调用，同时将创建产品的代码移入工厂方法。
你可能需要在工厂方法中`添加临时参数来控制返回的产品类型`。
- 为工厂方法中的每种产品`编写一个创建者子类`，然后在子类中重写工厂方法，并将基本方法中的相关创建代码移动到工厂方法中。
- 如果应用中的产品类型太多，那么为每个产品创建子类并无太大必要，这时你也`可以在子类中复用基类中的控制参数`。
- 如果代码经过上述移动后，基础工厂方法中已经没有任何代码，你可以将其转变为抽象方法。如果基础工厂方法中还有其他语句，
你可以将其设置为该方法的默认行为。

### 适用场景

- 当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。
- 如果你希望用户能扩展你软件库或框架的内部组件，可使用工厂方法。
  - 假设你使用开源UI框架编写自己的应用。你希望在应用中使用圆形按钮，但是原框架仅支持矩形按钮。
  你可以使用圆形按钮`RoundButton子类`来继承标准的按钮`Button类`。但是，
  你需要告诉UI框架`UIFramework类`使用新的子类按钮代替默认按钮。
  - 为了实现这个功能，你可以根据`基础框架类`开发子类`圆形按钮UI`-`UIWithRoundButtons`，并且重写其`createButton`创建按钮方法。
  基类中的该方法返回`按钮对象`，而你开发的子类返回`圆形按钮对象`。现在，你就可以使用`圆形按钮UI类`代替`UI框架类`。
- 如果你希望复用现有对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法。
  - 有一个既能够创建新对象，又可以重用现有对象的方法。

### 优缺点

- 优点
  - 你可以避免创建者和具体产品之间的紧密耦合。
  - `单一职责原则`。你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护。
  - `开闭原则`。无需更改现有客户端代码，你就可以在程序中引入新的产品类型。
- 缺点
  - 应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更复杂。最好的情况是将该模式引入创建者类的现有层次结构中。

### 与其它模式的关系

- 在许多设计工作的初期都会使用`工厂方法`（较为简单，而且可以更方便地通过子类进行定制），
随后演化为使用`抽象工厂`、`原型`或`生成器`（更灵活但更加复杂）。
- `抽象工厂`模式通常基于一组`工厂方法`，但你也可以使用`原型模式`来生成这些类的方法。
- 你可以同时使用`工厂方法`和`迭代器`来让子类集合返回不同类型的迭代器，并使得迭代器与集合相匹配。
- `原型`并不基于继承，因此没有继承的缺点。另一方面，原型需要对被复制对象进行复杂的初始化。`工厂方法`基于继承，
但是它不需要初始化步骤。
- `工厂方法`是`模板方法`的一种特殊形式。同时，`工厂方法`可以作为一个大型`模板方法`中的一个步骤。

### 示例说明

- 假设现在有一款物流管理应用（Logistics），目前只能管理卡车运输(Truck)

![](img/factory-method/initial-state.svg)

- 目前，物流管理应用的`planDelivery`方法只与卡车有关.如果添加海上业务，增加`轮船`类。则需要修改`planDelivery`方法代码。
  更糟糕的是。后面可能会出现更多的运输方式，每次增加，都得修改`planDelivery`方法。错误的示范如下：

![](img/factory-method/wrong-approach.svg)

- 上面的做法，每次增加交通设备都需要修改`planDelivery`方法。`工厂方法`解决了这个问题。
  将new对象的工作交给`工厂方法`。在`子类`中重写`工厂方法`，从而改变创建产品的类型。

![](img/factory-method/factory-method.svg)

### 示例代码实现

![](https://cdn.jsdelivr.net/gh/guosonglu/images@master/blog-img/202111241424290.png)

- 创建交通工具接口和实现类

```java
public interface Transport {
    /**
     * 运送接口
     */
    public void deliver();
}
```

```java
public class Truck implements Transport{

    /**
     * 运送接口
     */
    @Override
    public void deliver() {
        System.out.println("卡车运送货物");
    }
}
```

```java
public class Ship implements Transport{
    /**
     * 运送接口
     */
    @Override
    public void deliver() {
        System.out.println("轮船运送货物");
    }
}
```

- 创建物流类

```java
public abstract class Logistics {

    /**
     * 进行货物运送
     */
    public void planDeliver() {
        createTransport().deliver();
    }


    /**
     * 工厂方法
     *
     * 抽象方法，由子类实现，返回具体的交通工具
     *
     * @return 交通工具
     */
    public abstract Transport createTransport();
}
```

- 创建物流类子类实现工厂方法

```java
public class RoadLogistics extends Logistics{
    /**
     * @return 交通工具
     */
    @Override
    public Transport createTransport() {
        return new Truck();
    }
}
```

```java
public class SealLogistics extends Logistics{
    /**
     * @return 交通工具
     */
    @Override
    public Transport createTransport() {
        return new Ship();
    }
}
```

- 测试

```java
public class Demo {
    public static void main(String[] args) {
        //陆地物流
        Logistics roadLogistics = new RoadLogistics();
        roadLogistics.planDeliver();

        //海上物流
        Logistics sealLogistics = new SealLogistics();
        sealLogistics.planDeliver();
    }
}
```



# 结构型模式

# 行为型模式

## 模板方法模式

### 意图

在超类中定义了一个算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构既可以重新定义该算法的某些特定步骤

### 举例说明


